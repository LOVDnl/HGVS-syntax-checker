<?php
/*******************************************************************************
 *
 * LEIDEN OPEN VARIATION DATABASE (LOVD)
 *
 * Created     : 2020-03-09
 * Modified    : 2025-08-12
 *
 * Copyright   : 2004-2025 Leiden University Medical Center; http://www.LUMC.nl/
 * Programmer  : Ivo F.A.C. Fokkema <I.F.A.C.Fokkema@LUMC.nl>
 *
 *************/

if (!class_exists('HGVS')) {
    require_once('HGVS.php');
}

class LOVD_VV
{
    // This class defines the LOVD VV object, handling all Variant Validator calls.

    public $sURL = 'https://rest.variantvalidator.org/'; // The URL of the VV endpoint.
    public $aResponse = array( // The standard response body.
        'data' => array(),
        'messages' => array(),
        'warnings' => array(),
        'errors' => array(),
    );
    private $nMicroSecondsToSleep = 250000;
    private $tLastCall = 0;





    function __construct ($sURL = '')
    {
        // Initiates the VV object. Nothing much to do except for filling in the URL.

        if ($sURL) {
            // We don't test given URLs, that would take too much time.
            $this->sURL = rtrim($sURL, '/') . '/';
        }
        // __construct() should return void.
    }





    private function addFault (&$aData, $sFault, $sVariant, $HGVS = false)
    {
        // Parse and check VV's error message and add it to our output. We don't always agree with VV about what is a
        //  warning and what is an error. This code handles this well by parsing all messages and deciding for ourselves
        //  whether this is a fatal error or an innocent warning.

        if (!$aData || !is_array($aData) || !isset($aData['warnings']) || !isset($aData['errors'])) {
            return false;
        }

        // Clean the variant description.
        // If verifyVariant() would allow genomic NC-based variants, we'd have
        //  validation warnings of *all* affected transcripts, repeated for each
        //  transcript. Just a bunch of huge repeated arrays filled with errors.
        //  We'd have to make sure the errors here would be about the transcript
        //  we're analyzing now, but since we don't support genomic NC-based
        //  variants in verifyVariant(), we don't need to worry about that now.
        //  Note that this does not apply to NC(NM) variants, that select only
        //  one transcript and therefore, don't show these repeated errors.
        //  However, because error messages in verifyVariant() generated by an
        //  NC(NM) variant may only show the NM variant, we have to improve the
        //  cleaning of the error message to compensate.
        $sFault = str_replace(
            array(
                // Prefixed by an untouched variant...
                $sVariant . ': ',
                // Prefixed by the variant with parentheses removed and an = appended...
                str_replace(array('(', ')'), '', $sVariant) . '=: ', // Seen with NM_004006.2:c.(123del).
                // Prefixed by a short version of the variant with everything outside the parentheses removed.
                str_replace(array(strstr($sVariant, '(', true), '(', ')'), '', $sVariant) . ': '), '', $sFault);

        // All error messages should end with a period.
        if (substr($sFault, -1) != '.') {
            $sFault .= '.';
        }

        // VV has declared their error messages are stable.
        // This means we can parse them and rely on them not to change.
        // Add error code if possible, so we won't have to parse the error message again somewhere.
        if (strtolower(substr($sFault, 0, 4)) == 'lovd') {
            // These are our own warnings fed back to us. VV uses the HGVS syntax checker now.
            // Ignore this error.
            return true;

        } elseif (strpos($sFault, ' automapped to ') !== false // LRG and LRGt descriptions being mapped to refseq sequences.
            || strpos($sFault, ' updated to ') !== false) {
            // E.g.: NC_000017.10:g.48275363delC && NM_000088.3:c.589delG.
            // Toss this error. These are several corrections, and we handle those elsewhere.
            return true;

        } elseif ($sFault == 'Trailing digits are not permitted in HGVS variant descriptions.'
            || strpos($sFault, 'Refer to http') !== false) {
            // We silently skip these warnings. They are handled elsewhere.
            // E.g., NC_000017.10:g.1_2dup4.
            return true;

        } elseif (strpos($sFault, ' is pending therefore changes may be made to the LRG reference sequence') !== false
            || $sFault == 'RefSeqGene record not available'
            || strpos($sFault, 'Query gene2transcripts with search term') === 0
            || strpos($sFault, 'is missing from the Universal Transcript Archive') !== false) {
            // All kinds of warnings that are not directly important, because they either are given
            //  with other messages that are handled, or because they are irrelevant.
            // E.g., NC_000017.10(NM_000088.3):c.5000del; c.5000 is in the UTR.
            return true;

        } elseif (preg_match('/^None of the specified transcripts \(.+\) fully overlap the described variation in the genomic sequence\./', $sFault)) {
            // When we send an NG or LRG and there are no transcripts overlapping. VV (from v3.0.0) does not allow
            //  asking for "all" transcripts anymore, so now we get this when we default to "select".
            // Currently, we decide to ignore it. We simply show that there are no transcripts overlapping.
            return true;

        } elseif (strpos($sFault, 'Invalid genome build has been specified') !== false) {
            // EBUILD error. Only thrown by the VV endpoint when manually a bad build has been sent.
            $aData['errors']['EBUILD'] = $sFault;

        } elseif (strpos($sFault, 'is not associated with genome build') !== false
            || strpos($sFault, 'No transcript definition for') !== false
            || strpos($sFault, 'is not in our database. Please check the transcript') !== false) {
            // EREFSEQ error. This also happens if we send the wrong build over the LOVD endpoint.
            // E.g., NC_000017.10:g.48275363delC with GRCh38.
            // E.g., NM_000088.1:c.589G>T (transcript version too old).
            $aData['errors']['EREFSEQ'] = $sFault;

        } elseif (preg_match('/^Failed to fetch .+ out of range/', $sFault) // NC with a coordinate that is too large.
            || strpos($sFault, 'is outside the boundaries of reference sequence') !== false // LRG:g with a coordinate that is too large.
            || strpos($sFault, 'The given coordinate is outside the bounds of the reference sequence') !== false // NC(NM) or LRGt with a c outside the NM.
            || strpos($sFault, ' variant position that lies outside of the reference sequence') !== false // LRGt or NM with a c* outside the NM.
            || $sFault == 'OutOfBoundsError: start or end or both are beyond the bounds of transcript record.' // NC(NM), LRGt, or NM with an invalid intronic position.
            || strpos($sFault, 'Variant coordinate is out of the bound of CDS region') !== false) { // NC(NM), LRGt, or NM with a c that should be a c*.
            // ERANGE error. VV throws a range of different messages, depending on using NC-notation or not,
            //  sending variants 5' or 3' of the transcript, or sending a CDS position that should be in the 3' UTR.
            $aData['errors']['ERANGE'] = $sFault;

        } elseif (strpos($sFault, 'does not agree with reference sequence') !== false) {
            // EREF error.
            $aData['errors']['EREF'] = $sFault;

        } elseif ($sFault == 'Length implied by coordinates must equal sequence deletion length.'
            || $sFault == 'Length implied by coordinates must equal sequence duplication length.') {
            // EINCONSISTENTLENGTH error. The LOVD endpoint will often combine this with other messages.
            // E.g., NC_000017.10:g.1_2delAAAA or NC_000017.10:g.1_2del4.
            // This only happens with duplications with a numeric length, e.g., NC_000017.10:g.1_2dup4.
            $aData['errors']['EINCONSISTENTLENGTH'] = $sFault;

        } elseif (strpos($sFault, 'ExonBoundaryError:') !== false) {
            // EINVALIDBOUNDARY error, the position is not an exon/intron boundary.
            // E.g., NM_003006.4:c.100+1del.
            $aData['errors']['EINVALIDBOUNDARY'] = $sFault;

        } elseif (substr($sFault, 0, 5) == 'char '
            || strpos($sFault, 'Insertion length must be 1') !== false // NC_000017.10:g.1_1insA.
            || strpos($sFault, ' must be provided ') !== false) {
            // ESYNTAX error. That is odd, because we should have filtered out variants that are not supported by VV.
            // Double-check if maybe somebody forced us to send an invalid syntax over.
            if ($HGVS && $HGVS->isValid()) {
                // Nope, I guess it's our fault. We're missing a WNOTSUPPORTED.
                $aData['warnings']['WNOTSUPPORTED'] =
                    'Although this variant is a valid HGVS description, this syntax is currently not supported for mapping and validation by VariantValidator.';
            } else {
                // We deliberately sent an invalid variant to VV.
                // OK, fine, forward the VV error.
                $aData['errors']['ESYNTAX'] = $sFault;
            }

        } elseif (preg_match(
                '/^(?:TranscriptVersionWarning: )?A more recent version of the selected reference sequence (.+) is available(?: for genome build .+)? \((.+)\)/',
                $sFault, $aRegs) || strpos($sFault, 'TranscriptVersionWarning:') === 0) {
            // This is not that important, but we won't completely discard it, either.
            if ($aRegs) {
                // We matched a precise reference sequence. However, double-check if we actually provided it.
                // Because when sending in an NG (e.g., NG_007400.1:g.8638G>T), we can get this message for a transcript
                //  we didn't come up with (e.g., NM_000088.3). That would make no sense to the user.
                if (strstr($sVariant, ':', true) == $aRegs[1]) {
                    $aData['messages']['IREFSEQUPDATED'] = 'Reference sequence ' . $aRegs[1] . ' can be updated to ' . $aRegs[2] . '.';
                }
            } else {
                // The description changed again, but we found the warning code at least.
                $aData['messages']['IREFSEQUPDATED'] = 'The reference sequence used can be updated.';
            }

        } elseif (preg_match(
            '/^The following versions of the requested transcript are available in our database: (.+)$/',
            $sFault, $aRegs)) {
            // This will help the user pick a transcript version that works.
            $aData['messages']['IREFSEQUPDATED'] = 'Reference sequence can be updated to one of: ' . str_replace('|', ', ', $aRegs[1]);

        } elseif (strpos($sFault, 'Interval end position ') === 0) {
            // E.g., NC_000017.10:g.2000_1000del.
            $aData['warnings']['WPOSITIONFORMAT'] = 'The positions are not given in the correct order. Please verify your description and try again.';

        } elseif ($sFault == 'VariantSyntaxError: Removing redundant reference bases from variant description.') {
            // verifyGenomic() returns this only when combined with something else, like: NC_000017.10:g.100_200delAAAA.
            // verifyVariant() also returns this for, e.g., NM_000088.3:c.589delG.
            // Use our own warning if we have that, since it's better.
            if ($HGVS && $HGVS->hasMessage('WSUFFIXGIVEN')) {
                $aData['warnings']['WSUFFIXGIVEN'] = $HGVS->getMessages()['WSUFFIXGIVEN'];
            } else {
                $aData['warnings']['WSUFFIXGIVEN'] = $sFault;
            }

        } else {
            // Unrecognized error.
            $aData['errors'][] = $sFault;
        }

        return true;
    }





    private function callVV ($sMethod, $aArgs = array())
    {
        // Wrapper function to call VV's JSON webservice.
        // Because we have a wrapper, we can implement CURL, which is much faster on repeated calls.
        global $_CONF;

        // Don't overload VV. Make sure we wait at least 0.25 seconds between calls.
        $nTimeDiff = (microtime(true) - $this->tLastCall) * 1000000;
        if ($nTimeDiff < $this->nMicroSecondsToSleep) {
            usleep(round($this->nMicroSecondsToSleep - $nTimeDiff));
        }
        $this->tLastCall = microtime(true);

        // Build URL, regardless of how we'll connect to it.
        $sURL = $this->sURL . $sMethod . '/' . implode('/', array_map('rawurlencode', $aArgs)) . '?content-type=application%2Fjson';
        $sJSONResponse = '';

        if (function_exists('curl_init')) {
            // Initialize curl connection.
            static $hCurl;

            if (!$hCurl) {
                $hCurl = curl_init();
                curl_setopt($hCurl, CURLOPT_RETURNTRANSFER, true); // Return the result as a string.
                curl_setopt($hCurl, CURLOPT_FOLLOWLOCATION, true); // Make sure we follow redirects.
                // Set a version so that VV can recognize us.
                curl_setopt($hCurl, CURLOPT_USERAGENT, 'LOVD/VV:' . HGVS::getVersions()['library_version']);

                // Set proxy, if we are used from within LOVD and LOVD requires a proxy.
                if (!empty($_CONF['proxy_host'])) {
                    curl_setopt($hCurl, CURLOPT_PROXY, $_CONF['proxy_host'] . ':' . $_CONF['proxy_port']);
                    if (!empty($_CONF['proxy_username']) || !empty($_CONF['proxy_password'])) {
                        curl_setopt($hCurl, CURLOPT_PROXYUSERPWD, $_CONF['proxy_username'] . ':' . $_CONF['proxy_password']);
                    }
                }
            }

            curl_setopt($hCurl, CURLOPT_URL, $sURL);
            $sJSONResponse = curl_exec($hCurl);

        } elseif (function_exists('lovd_php_file')) {
            // Backup method, no curl installed. We'll try LOVD's file() implementation, which also handles proxies.
            $aJSONResponse = lovd_php_file($sURL);
            if ($aJSONResponse !== false) {
                $sJSONResponse = implode("\n", $aJSONResponse);
            }

        } else {
            // Last fallback. Requires fopen wrappers.
            $aJSONResponse = file($sURL);
            if ($aJSONResponse !== false) {
                $sJSONResponse = implode("\n", $aJSONResponse);
            }
        }



        if ($sJSONResponse) {
            $aJSONResponse = @json_decode($sJSONResponse, true);
            if ($aJSONResponse !== false) {
                return $aJSONResponse;
            }
        }
        // Something went wrong...
        return false;
    }





    private function detectDNAChangeType (&$aData, $sVariant, $HGVS = false)
    {
        // This functions checks why the variant returned by VV and the input variant differ.
        // It checks types of corrections; silent, WCORRECTED, WROLLFORWARD, or WSUFFIXGIVEN.

        if (!$aData || !is_array($aData) || !isset($aData['warnings']) || !isset($aData['errors'])
            || !isset($aData['data']['DNA']) || $aData['data']['DNA'] == $sVariant) {
            return false;
        }

        if ($HGVS) {
            // Parse the new description.
            $HGVSCorrected = HGVS::check($aData['data']['DNA'])->requireVariant();

            // Multiple problems can occur at the same time
            //  (e.g., NC_000004.11:g.39350045delA => NC_000004.11:g.39350048del),
            //  and VV keeps that WSUFFIXGIVEN silent. Check it first.
            if ($HGVS->hasMessage('WSUFFIXGIVEN')) {
                $aData['warnings']['WSUFFIXGIVEN'] = $HGVS->getMessages()['WSUFFIXGIVEN'];
            }

            $aVariantInfo = $HGVS->getData();
            $aVariantInfoCorrected = $HGVSCorrected->getData();
            if ($aVariantInfo == $aVariantInfoCorrected) {
                // Positions and type are the same, small corrections like delG to del.
                // We let these pass silently.

            } elseif ($aVariantInfo['type'] != $aVariantInfoCorrected['type']) {
                // An insertion actually being a duplication.
                // A deletion-insertion which is actually something else.
                // A 1_1del that should be 1del (although our HGVS library would have caught that, if it was used).
                $aData['warnings']['WCORRECTED'] = 'The variant description has been corrected.';
                if ($aVariantInfoCorrected['type'] == '=') {
                    $aData['warnings']['WCORRECTED'] .= ' Did you mean to indicate that the sequence at this position did not change?';
                } else {
                    $aData['warnings']['WCORRECTED'] .= ' Based on the sequence, this should be described as ' .
                        ($aVariantInfoCorrected['type'] == '>'? 'a substitution.' :
                            ($aVariantInfoCorrected['type'] == 'del'? 'a deletion.' :
                                ($aVariantInfoCorrected['type'] == 'delins'? 'a deletion-insertion.' :
                                    ($aVariantInfoCorrected['type'] == 'dup'? 'a duplication.' :
                                        ($aVariantInfoCorrected['type'] == 'ins'? 'an insertion.' : 'an inversion.')))));
                }

            } else {
                // Positions are different, but type is the same.
                // 3' forwarding of deletions, insertions, duplications
                //  and deletion-insertion events or other corrections to the position.
                $aData['warnings']['WROLLFORWARD'] = 'Variant position' .
                    (!$aVariantInfo['range']? ' has' : 's have') .
                    ' been corrected.';
            }

        } else {
            // We didn't receive the HGVS object, just complain here.
            $aData['warnings']['WCORRECTED'] = 'The variant description has been corrected.';
        }

        return true;
    }





    private function getRNAProteinPrediction (&$aMapping, $sTranscript = '')
    {
        // Function to predict the RNA change and to improve VV's protein prediction.
        // $aMapping will be extended with 'RNA' and 'protein' if they don't already exist.
        // $sTranscript is just used to check if this is a coding or non-coding transcript.

        if (!is_array($aMapping) || !isset($aMapping['DNA'])) {
            // Without DNA, we can do nothing.
            return false;
        }

        if (!isset($aMapping['RNA'])) {
            $aMapping['RNA'] = 'r.(?)';
        }
        if (!isset($aMapping['protein'])) {
            $aMapping['protein'] = '';
        }

        // Check values, perhaps we can do better.
        if (substr($aMapping['DNA'], -1) == '=') {
            // DNA actually didn't change. Protein will indicate the same.
            $aMapping['RNA'] = 'r.(=)';
            // FIXME: VV returns p.(Ala86=) rather than p.(=); perhaps return r.(257=) instead of r.(=).
            // For UTRs or p.Met1, a c.= returns a p.? (safe choice). I prefer a p.(=).
            if ($aMapping['protein'] == 'p.?' || $aMapping['protein'] == 'p.(Met1?)') {
                $aMapping['protein'] = 'p.(=)';
            }

        } elseif (in_array($aMapping['protein'], array('', 'p.?', 'p.(=)'))) {
            // The HGVS library is generally fast, so we don't have to worry about slowdowns.
            $HGVS = HGVS::check($aMapping['DNA'])->requireVariant();
            if ($HGVS->isAVariant()) {
                // We'd want to check this.
                $aVariantInfo = $HGVS->getData();
                // Splicing.
                if (($aVariantInfo['position_start_intron'] && abs($aVariantInfo['position_start_intron']) <= 5)
                    || ($aVariantInfo['position_end_intron'] && abs($aVariantInfo['position_end_intron']) <= 5)
                    || ($aVariantInfo['position_start_intron'] && !$aVariantInfo['position_end_intron'])
                    || (!$aVariantInfo['position_start_intron'] && $aVariantInfo['position_end_intron'])) {
                    $aMapping['RNA'] = 'r.spl?';
                    $aMapping['protein'] = 'p.?';

                } elseif ($aVariantInfo['position_start_intron'] && $aVariantInfo['position_end_intron']
                    && abs($aVariantInfo['position_start_intron']) > 5 && abs($aVariantInfo['position_end_intron']) > 5
                    && ($aVariantInfo['position_start'] == $aVariantInfo['position_end']
                        || ($aVariantInfo['position_start'] + 1) == $aVariantInfo['position_end'])) {
                    // Deep intronic.
                    $aMapping['RNA'] = 'r.(=)';
                    $aMapping['protein'] = 'p.(=)';

                } else {
                    // No introns involved. Note, position fields are sorted.
                    if ($aVariantInfo['position_end'] < 0) {
                        // Variant is completely upstream of the CDS.
                        $aMapping['RNA'] = 'r.(?)';
                        $aMapping['protein'] = 'p.(=)';

                    } elseif ($aVariantInfo['position_start'] < 0 && strpos($aMapping['DNA'], '*') !== false) {
                        // Start is upstream, end is downstream.
                        if ($aMapping['type'] == 'del') {
                            $aMapping['RNA'] = 'r.0?';
                            $aMapping['protein'] = 'p.0?';
                        } else {
                            $aMapping['RNA'] = 'r.?';
                            $aMapping['protein'] = 'p.?';
                        }

                    } elseif (substr($aMapping['DNA'], 0, 3) == 'c.*') {
                        // Variant is completely downstream of the CDS.
                        $aMapping['RNA'] = 'r.(?)';
                        $aMapping['protein'] = 'p.(=)';

                    } elseif ($aVariantInfo['type'] != '>' && $aMapping['protein'] != 'p.(=)') {
                        // Non-SNVs partially in the transcript, not predicted to do nothing.
                        $aMapping['RNA'] = 'r.?';
                        $aMapping['protein'] = 'p.?';

                    } else {
                        // Substitution on wobble base or so.
                        $aMapping['RNA'] = 'r.(?)';
                    }
                }

                // But wait, did we just fill in a protein field for a non-coding transcript?
                if (substr($sTranscript, 1, 1) == 'R') {
                    $aMapping['protein'] = '';
                }
            }
        }

        return true;
    }





    public function getTranscriptsByID ($sSymbol)
    {
        // Returns the available transcripts for the given gene or transcript.
        // When a transcript has been passed, it returns only that transcript (any version).

        $bTranscript = preg_match('/^[NX][MR]_[0-9.]+$/', $sSymbol);
        // For now, let's remove the version to just match anything.
        // VV's output does not depend on this, but our checks further down do.
        if ($bTranscript) {
            $sSymbol = strstr($sSymbol . '.', '.', true);
        }

        // FIXME: We're not ready to use the v2 of the endpoint. Issues:
        //        - Genome builds have to be sent has NCBI IDs (GRCh37, not hg19).
        //        - When filtering for a certain transcript, the endpoint is not significantly faster and you can't filter for, e.g., "NM_002225".
        //          That will return nothing, you NEED to specify a version.
        //          That makes that addition quite useless for us, so the only thing left is that you can pass on a build.
        //          That is not very relevant at the moment when I'm rebuilding this class, so I'm leaving it.
        $aJSON = $this->callVV('VariantValidator/tools/gene2transcripts', array(
            'id' => $sSymbol,
        ));
        if ($aJSON && is_array($aJSON) && count($aJSON) == 1 && isset($aJSON[0])) {
            // Handle https://github.com/openvar/variantValidator/issues/579.
            // The output was suddenly a list instead of the expected object.
            $aJSON = current($aJSON);
        }
        if (!$aJSON || empty($aJSON['transcripts'])) {
            // Failure.
            // OK, but... what if we were working on chrM? And VV doesn't support these yet?
            if ($aJSON && isset($aJSON['current_symbol']) && substr($aJSON['current_symbol'], 0, 3) == 'MT-') {
                // Collect all NCs and builds for chrM.
                $aNCs = [];
                foreach (array_keys(HGVS_Genome::getBuilds()) as $sBuild) {
                    $sNC = HGVS_ReferenceSequence::check($sBuild . ':chrM')->getCorrectedValue();
                    if (isset($aNCs[$sNC])) {
                        $aNCs[$sNC][] = $sBuild;
                    } else {
                        $aNCs[$sNC] = [$sBuild];
                    }
                }
                $aData = [];
                foreach ($aNCs as $sNC => $aBuilds) {
                    $aData[$sNC . '(' . $aJSON['current_symbol'] . ')'] = [
                        'name' => 'transcript variant 1',
                        'id_ncbi_protein' => '',
                        'genomic_positions' => array_combine(
                            $aBuilds,
                            array_map(
                                function ($sBuild)
                                {
                                    return [
                                        'M' => [
                                            'start' => null,
                                            'end' => null,
                                        ]
                                    ];
                                }, $aBuilds)),
                        'transcript_positions' => [
                            'cds_start' => null,
                            'cds_length' => null,
                            'length' => null,
                        ],
                        'select' => false,
                    ];
                }

                return array_merge(
                    $this->aResponse,
                    [
                        'data' => $aData,
                    ]
                );
            }
            return array_merge($this->aResponse, ['errors' => 'No transcripts found.']);
        }

        $aData = $this->aResponse;
        foreach ($aJSON['transcripts'] as $aTranscript) {
            // If we requested a single transcript, show only those.
            if ($bTranscript && strpos($aTranscript['reference'], $sSymbol . '.') === false) {
                continue;
            }

            // Clean name.
            $sName = preg_replace(
                array(
                    '/^Homo sapiens\s+/', // Remove species name.
                    '/^' . preg_quote($aJSON['current_name'], '/') . '\s+/', // The current gene name.
                    '/.*\(' . preg_quote($aJSON['current_symbol'], '/') . '\),\s+/', // The current symbol.
                    '/, mRNA\b/', // mRNA suffix.
                    '/, non-coding RNA$/', // non-coding RNA suffix, replaced to " (non-coding)".
                    '/; nuclear gene for mitochondrial product$/', // suffix given to a certain class of genes.
                ), array('', '', '', '', ' (non-coding)', ''), $aTranscript['description']);

            // Figure out the genomic positions, which are given to us using the NCs.
            $aGenomicPositions = array_fill_keys(array_keys(HGVS_Genome::getBuilds()), []);
            foreach ($aTranscript['genomic_spans'] as $sRefSeq => $aMapping) {
                $aNCInfo = HGVS_Chromosome::getInfoByNC($sRefSeq);
                if ($aNCInfo) {
                    $sBuild = $aNCInfo['build'];
                    $sChromosome = $aNCInfo['chr'];
                    $aGenomicPositions[$sBuild][$sChromosome] = array(
                        'start' => ($aMapping['orientation'] == 1?
                            $aMapping['start_position'] : $aMapping['end_position']),
                        'end' => ($aMapping['orientation'] == 1?
                            $aMapping['end_position'] : $aMapping['start_position']),
                    );
                }
            }

            $aData['data'][$aTranscript['reference']] = array(
                'gene_symbol' => $aJSON['current_symbol'],
                'gene_hgnc' => substr(strstr($aJSON['hgnc'] ?? '', ':'), 1),
                'name' => $sName,
                'id_ncbi_protein' => $aTranscript['translation'],
                'genomic_positions' => $aGenomicPositions,
                'transcript_positions' => array(
                    'cds_start' => $aTranscript['coding_start'],
                    'cds_length' => (!$aTranscript['coding_end']? NULL : ($aTranscript['coding_end'] - $aTranscript['coding_start'] + 1)),
                    'length' => $aTranscript['length'],
                ),
                'select' => ($aTranscript['annotations']['db_xref']['select'] ?? false),
            );
        }

        ksort($aData['data'], SORT_NATURAL);
        return $aData;
    }





    public function getVersions ()
    {
        return ($this->callVV('hello')['metadata'] ?? []);
    }





    public function test ()
    {
        // Tests the VV endpoint.

        $aJSON = $this->callVV('hello');
        if (!$aJSON) {
            // Failure.
            return false;
        }

        if (isset($aJSON['status']) && $aJSON['status'] == 'hello_world') {
            // All good.
            return true;
        } else {
            // Something JSON, but perhaps another format?
            return 0;
        }
    }





    public function verifyGenomic ($sVariant, $aOptions = array())
    {
        // Verify a genomic variant, and optionally get mappings and a protein prediction.

        if (empty($aOptions) || !is_array($aOptions)) {
            $aOptions = array();
        }

        // Perform some extra checks. We assume here that this variant description is what we want to send to VV.
        // We will not use fixes created by the HGVS object, because this wil stop us from sending whatever we want.
        // We do, however, demand that we have a variant with a reference sequence.
        $HGVS = HGVS::check($sVariant)->requireVariant();
        if (strpos($HGVS->getIdentifiedAs(), 'full_variant') !== 0) {
            if ($HGVS->hasMessage('EREFSEQMISSING')) {
                $this->aResponse['errors']['EREFSEQMISSING'] = $HGVS->getMessages()['EREFSEQMISSING'];
            } elseif ($HGVS->hasMessage('EVARIANTREQUIRED')) {
                $this->aResponse['errors']['EVARIANTREQUIRED'] = $HGVS->getMessages()['EVARIANTREQUIRED'];
            }
            return $this->aResponse;
        }

        // VV doesn't support everything.
        if ($HGVS->hasMessage('WNOTSUPPORTED')) {
            $this->aResponse['errors']['ENOTSUPPORTED'] = 'VariantValidator does not currently support this type of variant description.';
            return $this->aResponse;
        }

        // Don't send variants that are too big; VV can't currently handle them.
        // These sizes are approximate and slightly on the safe side;
        //  simple measurements have shown a maximum duplication size of
        //  250KB, and a max deletion of 900KB, requiring a full minute.
        // See: https://github.com/openvar/variantValidator/issues/151
        $aVariantInfo = $HGVS->getInfo()['data'];
        if ($aVariantInfo
            && (($aVariantInfo['type'] == 'dup' && ($aVariantInfo['position_end'] - $aVariantInfo['position_start']) > 200000)
                || (substr($aVariantInfo['type'], 0, 3) == 'del' && ($aVariantInfo['position_end'] - $aVariantInfo['position_start']) > 800000))) {
            // Variant too big, return error.
            $aReturn = $this->aResponse;
            $aReturn['errors']['ESIZETOOLARGE'] = 'This variant is currently too big to process. It will likely time out after a minute of waiting, so we won\'t send it to VariantValidator.';
            return $aReturn;
        }

        // Append defaults for any remaining options.
        $aOptions = array_replace(
            array(
                'map_to_transcripts' => false, // Should we map the variant to transcripts?
                'predict_protein' => false,    // Should we get protein predictions?
                'lift_over' => false,          // Should we get other genomic mappings of this variant?
                'select_transcripts' => 'all', // Should we limit our output to only a certain set of transcripts?
            ),
            $aOptions);

        // Some options require others.
        // We want to map to transcripts also if we're asking for a liftover, and if we want protein prediction.
        $aOptions['map_to_transcripts'] = ($aOptions['map_to_transcripts'] || $aOptions['lift_over'] || $aOptions['predict_protein']);

        // Deduce the build from the given NC. That works reliably for everything except chrM.
        // For chrM, we just match GRCh37 because that's the first.
        $sNC = strstr($sVariant, ':', true);
        $aNCInfo = HGVS_Chromosome::getInfoByNC($sNC);
        if ($aNCInfo) {
            // We pick the NCBI name here, because for chrM we actually
            //  use GRCh37's NC_012920.1 instead of hg19's NC_001807.4.
            $sBuild = HGVS_Genome::getBuilds()[$aNCInfo['build']];

        } else {
            // If we didn't get the build (no NC or invalid NC), then the whole call will fail.
            // Note that this endpoint doesn't support anything other than NC:g input.
            return false;
        }

        // Transcript list should be a list, 'all', 'select', 'mane', or 'mane_select'.
        if (!$aOptions['select_transcripts']
            || (!is_array($aOptions['select_transcripts'])
                && !in_array(strtolower($aOptions['select_transcripts']), array('all', 'select', 'mane', 'mane_select')))) {
            $aOptions['select_transcripts'] = 'all';
        }

        $aJSON = $this->callVV('LOVD/lovd', array(
            'genome_build' => $sBuild,
            'variant_description' => $sVariant,
            'transcripts' => 'refseq', // 'all' includes Ensembl transcripts that are very slow (still so @ March 2025).
            'select_transcripts' => (!is_array($aOptions['select_transcripts'])?
                $aOptions['select_transcripts'] :
                implode('|', $aOptions['select_transcripts'])),
            'check_only' => ($aOptions['predict_protein']?
                'False' : ($aOptions['map_to_transcripts']? 'tx' : 'True')),
            'lift_over' => ($aOptions['lift_over']? 'primary' : 'False'),
        ));
        if (!$aJSON || empty($aJSON[$sVariant])) {
            // Failure. This happens when VV fails hard or if we can't find our input back in the output.
            // We should have stopped unsupported variant descriptions because we already checked for WNOTSUPPORTED.
            // So this should be an VV error.
            return false;
        }

        $aData = $this->aResponse;

        // Discard the meta data.
        $aJSON = $aJSON[$sVariant];

        // We'll copy the errors, but I've never seen them filled in, even with REF errors.
        $aData['errors'] = $aJSON['errors'];

        // Check the flag value.
        if ($aJSON['flag']) {
            switch ($aJSON['flag']) {
                case 'genomic_variant_warning':
                    if ($aJSON[$sVariant]['genomic_variant_error']) {
                        // This should be an array, but VV puts everything in a string.
                        // https://github.com/openvar/variantValidator/issues/667.
                        // Try to split things.
                        $aFaults = explode(
                            "\n",
                            preg_replace(
                                "/\.?, ([A-Z][a-z]|NC)/",
                                ".\n$1",
                                $aJSON[$sVariant]['genomic_variant_error']
                            )
                        );
                        foreach ($aFaults as $sFault) {
                            $this->addFault($aData, $sFault, $sVariant, $HGVS);
                        }
                        // When we have errors, we don't need 'data' filled in. Just return what I have.
                        if ($aData['errors']) {
                            return $aData;
                        } else {
                            // Warnings were a false alarm (warnings or even less).
                            $aJSON[$sVariant]['genomic_variant_error'] = '';
                        }
                    }
                    break;

                case 'processing_error':
                    // This happens, for instance, when we ask to select a
                    //  transcript that this variant actually doesn't map on.
                    // Also, sometimes VV (well, UTA) gives us a transcript
                    //  voluntarily, but VV can't map our variant with it.
                    // E.g., NC_000017.10:g.41271863_41308933del.
                    $aFailingTranscripts = array();
                    foreach ($aJSON[$sVariant]['hgvs_t_and_p'] as $sTranscript => $aTranscript) {
                        if (!empty($aTranscript['transcript_variant_error'])) {
                            $aFailingTranscripts[] = $sTranscript;
                        }
                    }

                    // If not all our transcripts failed, just remove the ones that did.
                    if (count($aFailingTranscripts) < count($aJSON[$sVariant]['hgvs_t_and_p'])) {
                        foreach ($aFailingTranscripts as $sTranscript) {
                            unset($aJSON[$sVariant]['hgvs_t_and_p'][$sTranscript]);
                        }
                        // Continue.
                        break;
                    }

                    // If we have selected transcripts, they all failed.
                    // If that is the case, retry without selecting any.
                    if (is_array($aOptions['select_transcripts'])
                        && count($aOptions['select_transcripts'])) {
                        unset($aOptions['select_transcripts']);
                        return $this->verifyGenomic($sVariant, $aOptions);
                    }
                    // No break; if we don't catch the error above here,
                    //  we want the error below.

                default:
                    // Unhandled flag. "processing_error" can still be
                    //  thrown, if all transcripts fail.
                    if ($aJSON['flag'] == 'processing_error') {
                        $aData['warnings']['WFLAG'] = 'VV Flag not handled: ' . $aJSON['flag'] . '. This happens when UTA passes transcripts that VV cannot map to.';
                    } else {
                        $aData['errors']['EFLAG'] = 'VV Flag not recognized: ' . $aJSON['flag'] . '. This indicates a feature is missing in LOVD.';
                    }
                    break;
            }
        }

        // Discard the errors array and the flag value.
        $aJSON = $aJSON[$sVariant];

        // Copy the (corrected) DNA value.
        $aData['data']['DNA'] = $aJSON['g_hgvs'];

        // If description is given but different, then apparently there's been some kind of correction.
        if ($aData['data']['DNA'] && $sVariant != $aData['data']['DNA']) {
            // Check why the variant returned by VV and the input variant differ.
            $this->detectDNAChangeType($aData, $sVariant, $HGVS);
        }

        // Any additional errors given?
        if ($aJSON['genomic_variant_error']) {
            // Not a previously seen error; those are handled through the flag value.
            // We'll assume a warning.
            $this->addFault($aData, $aJSON['genomic_variant_error'], $sVariant, $aVariantInfo);
        }

        // Did we get any mappings to transcripts?
        $aData['data']['genomic_mappings'] = array();
        $aData['data']['transcript_mappings'] = array();
        foreach (($aJSON['hgvs_t_and_p'] ?? []) as $sTranscript => $aTranscript) {
            if ($sTranscript != 'intergenic' && empty($aTranscript['transcript_variant_error'])) {
                // We silently ignore transcripts here that gave us an error, but not for the liftover feature.
                $aMapping = array(
                    'DNA' => '',
                    'RNA' => (!$aOptions['predict_protein']? '' : 'r.(?)'),
                    'protein' => '',
                    'NP' => '',
                );
                if ($aTranscript['gap_statement'] || $aTranscript['gapped_alignment_warning']) {
                    // This message might be repeated for multiple transcripts when there are gapped alignments,
                    //  and perhaps repeated also for multiple genome builds (untested).
                    // Currently, we just store one warning message.
                    $aData['warnings']['WALIGNMENTGAPS'] = 'Given alignments may contain artefacts; there is a gapped alignment between transcript and genome build.';
                }
                if ($aTranscript['t_hgvs']) {
                    // Collect the cDNA change and remove the reference sequence.
                    $aMapping['DNA'] = substr(strstr($aTranscript['t_hgvs'], ':'), 1);
                }
                if ($aTranscript['p_hgvs_tlc']) {
                    // Collect the protein change and remove the reference sequence.
                    list($aMapping['NP'], $aMapping['protein']) = explode(':', $aTranscript['p_hgvs_tlc'], 2);
                }

                if ($aOptions['predict_protein']) {
                    // Try to improve VV's predictions.
                    $this->getRNAProteinPrediction($aMapping, $sTranscript);
                }
                $aData['data']['transcript_mappings'][$sTranscript] = $aMapping;
            }

            // Genomic mappings, when requested, are given per transcript (or otherwise as "intergenic").
            foreach (($aTranscript['primary_assembly_loci'] ?? []) as $sBuild => $aMappings) {
                // We support only the builds we have...
                if (!isset(HGVS_Genome::getBuilds()[$sBuild])) {
                    continue;
                }

                // There can be more than one mapping per build in theory, when transcripts map differently.
                foreach ($aMappings as $sRefSeq => $aMapping) {
                    $aData['data']['genomic_mappings'][$sBuild][] = $aMapping['hgvs_genomic_description'];
                }
            }
        }

        // Clean up duplicates from multiple transcripts.
        foreach ($aData['data']['genomic_mappings'] as $sBuild => $aMappings) {
            $aData['data']['genomic_mappings'][$sBuild] = array_unique($aMappings);
        }
        return $aData;
    }





    public function verifyGenomicAndMap ($sVariant, $aTranscripts = array())
    {
        // Wrapper to verify a genomic variant and map it to transcripts as well.

        return $this->verifyGenomic($sVariant,
            array(
                'map_to_transcripts' => true,
                'select_transcripts' => $aTranscripts,
            ));
    }





    public function verifyGenomicAndLiftOver ($sVariant, $aTranscripts = array())
    {
        // Wrapper to verify a genomic variant and lift it over to other genome builds
        //  (through transcript mapping if possible).

        return $this->verifyGenomic($sVariant,
            array(
                'lift_over' => true,
                'select_transcripts' => $aTranscripts,
            ));
    }





    public function verifyGenomicAndPredictProtein ($sVariant, $aTranscripts = array())
    {
        // Wrapper to verify a genomic variant, map it to transcripts, and get protein predictions as well.

        return $this->verifyGenomic($sVariant,
            array(
                'predict_protein' => true,
                'select_transcripts' => $aTranscripts,
            ));
    }





    public function verifyVariant ($sVariant, $aOptions = array())
    {
        // Verify a variant, get mappings and protein predictions.
        // Uses the VariantValidator API, in practice for both genomic and
        //  transcript variants. For NC:g variants, we're much happier using
        //  the LOVD endpoint (verifyGenomic()), so just use this method only
        //  for NG, LRG, and transcript variants.
        // For getting reference base verification, you'll need to pass the NC
        //  as well, in the format NC_000001.10(NM_123456.1):c.100del.

        if (empty($aOptions) || !is_array($aOptions)) {
            $aOptions = array();
        }

        // Perform some extra checks. We assume here that this variant description is what we want to send to VV.
        // We will not use fixes created by the HGVS object, because this wil stop us from sending whatever we want.
        // We do, however, demand that we have a variant with a reference sequence.
        $HGVS = HGVS::check($sVariant)->requireVariant();
        if (strpos($HGVS->getIdentifiedAs(), 'full_variant') !== 0) {
            if ($HGVS->hasMessage('EREFSEQMISSING')) {
                $this->aResponse['errors']['EREFSEQMISSING'] = $HGVS->getMessages()['EREFSEQMISSING'];
            } elseif ($HGVS->hasMessage('EVARIANTREQUIRED')) {
                $this->aResponse['errors']['EVARIANTREQUIRED'] = $HGVS->getMessages()['EVARIANTREQUIRED'];
            }
            return $this->aResponse;
        }

        // Disallow NC variants. We should use verifyGenomic() for these.
        // Supporting NCs using this function will just take a lot more code,
        //  which wouldn't be useful. Fail hard, to teach users to not do this,
        //  but don't fail on NC_000001.10(NM_123456.1):c. variants.
        if ($HGVS->ReferenceSequence->molecule_type == 'chromosome') {
            return false;
        }

        // VV doesn't support everything.
        if ($HGVS->hasMessage('WNOTSUPPORTED')) {
            $this->aResponse['errors']['ENOTSUPPORTED'] = 'VariantValidator does not currently support this type of variant description.';
            return $this->aResponse;
        }

        // Append defaults for any remaining options.
        // VV doesn't have as many options as the LOVD endpoint, and honestly,
        //  selecting transcripts is only useful when we're using NCs as input.
        $aOptions = array_replace(
            array(
                'select_transcripts' => 'select', // Should we limit our output to only a certain set of transcripts?
            ),
            $aOptions);

        // We only need a genome build to resolve intronic variants. We default to the latest build.
        $sBuild = array_key_last(HGVS_Genome::getBuilds());
        if ($HGVS->ReferenceSequence->molecule_type == 'genome_transcript') {
            $sNC = strstr($HGVS->ReferenceSequence->getCorrectedValue(), '(', true);
            $aNCInfo = HGVS_Chromosome::getInfoByNC($sNC);
            if ($aNCInfo) {
                $sBuild = $aNCInfo['build'];
            }
            // There is no else. We'll use our default and see what happens.
        }

        // We pick the NCBI name here, because for chrM we actually
        //  use GRCh37's NC_012920.1 instead of hg19's NC_001807.4.
        $sBuild = HGVS_Genome::getBuilds()[$sBuild];

        // Strip the NC off of the variant. VV gives us only the NM back, so we'll get confused, otherwise.
        // Also, the NC(NM) can cause issues.
        // See https://github.com/openvar/variantValidator/issues/218.
        $bRefSeqWasCleaned = false;
        if ($HGVS->ReferenceSequence->molecule_type == 'genome_transcript'
            && $HGVS->ReferenceSequence->getIdentifiedAs() != 'LRG_transcript') {
            // This is an NC(NM) or NG(NM). Discard the genomic component. We'll put it back later.
            $bRefSeqWasCleaned = true;
            $sVariant = substr(strstr($HGVS->ReferenceSequence->getCorrectedValue(), '('), 1, -1)
                . strstr($sVariant, ':');
        }

        // Transcript list should be a list, 'select', 'mane', or 'mane_select'.
        if (!$aOptions['select_transcripts']
            || (!is_array($aOptions['select_transcripts'])
                && !in_array(strtolower($aOptions['select_transcripts']), array('select', 'mane', 'mane_select')))) {
            $aOptions['select_transcripts'] = 'select';
        }

        $aJSON = $this->callVV('VariantValidator/variantvalidator', array(
            'genome_build' => $sBuild,
            'variant_description' => $sVariant,
            'select_transcripts' => (!is_array($aOptions['select_transcripts'])?
                $aOptions['select_transcripts'] :
                implode('|', $aOptions['select_transcripts'])),
        ));
        if (!$aJSON || empty($aJSON['flag'])) {
            // Failure. This happens when VV fails hard.
            // We should have stopped unsupported variant descriptions because we already checked for WNOTSUPPORTED.
            // So this should be an VV error.
            return false;
        }

        // See https://github.com/openvar/variantValidator/issues/421.
        // Sometimes VV returns incomplete output that seems to be based on somebody else's input.
        // But even then, a warning is thrown, so we can detect this easily.
        // We could loop and keep calling VV until we get back what we expect, but this might lead to an endless loop.
        // So, for now, simply repeat the call *once* if we find this problem.
        if ($aJSON['flag'] == 'warning'
            && array_keys(array_diff_key($aJSON, array('metadata' => 1, 'flag' => 1))) == array('validation_warning_1')
            && $aJSON['validation_warning_1']['submitted_variant'] != $sVariant) {
            // We got an empty warning with somebody else's input. We can't use this at all. Repeat or return false.
            if (empty($aOptions['repeated_call'])) {
                // This adds some overhead (re-processing of input and a recursive function call),
                //  but it's the simplest method.
                return $this->verifyVariant($sVariant, array_merge($aOptions, array('repeated_call' => 1)));
            } else {
                return false;
            }
        }

        $aData = $this->aResponse;

        // Discard the meta data.
        unset($aJSON['metadata']);

        // Check the flag value. In contrast to the LOVD endpoint, the VV flag is always filled in.
        switch ($aJSON['flag']) {
            case 'error':
                // VV failed completely. Nothing to do here...
                return false;
            case 'gene_variant':
                // All good. We can still have validation errors, but at least it's not a big warning.
                break;
            case 'intergenic':
                // This can only happen when passing NC:g or NG:g variants that don't overlap with any transcripts.
                // NC(NM)-based variants that are outside the transcript's boundaries are returning a warning flag.
                // Since we support NG variants in this endpoint, we have to handle this.
                // Remove some unknown rogue entry in the JSON data.
                unset($aJSON['']);
                // Then, continue normally. There's still data to process.
                break;
            case 'warning':
                // Something's wrong. Parse given warning and quit.
                foreach (($aJSON['validation_warning_1']['validation_warnings'] ?? []) as $sError) {
                    $this->addFault($aData, $sError, $sVariant, $HGVS);
                }
                // When we have errors, we don't need 'data' filled in. Just return what I have.
                if ($aData['errors']) {
                    return $aData;
                } else {
                    // Warnings were a false alarm (warnings or even less).
                    unset($aJSON['validation_warning_1']);
                }
                break;
            // Handled all possible flags, no default needed.
        }
        // Discard the flag value.
        unset($aJSON['flag']);

        // If we have nothing left here, the given validation warning didn't contain any useful output.
        if (!$aJSON) {
            // E.g., NM_000088.3:c.589G. While the interface has output ("char 19: end of input"), the API does not.
            // In this case, let the user know what the HGVS library thought of this variant.
            if ($HGVS->isValid()) {
                // I guess it's our fault. We're missing a WNOTSUPPORTED.
                $aData['warnings']['WNOTSUPPORTED'] =
                    'Although this variant is a valid HGVS description, this syntax is currently not supported for mapping and validation by VariantValidator.';
            } else {
                // We deliberately sent an invalid variant to VV.
                $aData = array_merge_recursive(
                    $aData,
                    $HGVS->getMessagesByGroup()
                );
                // Also explain that VV failed.
                $aData['errors']['EFAIL'] = 'VariantValidator failed to recognize a HGVS nomenclature-compliant variant description in your input.';
            }
            return $aData;
        }

        // Add a warning in case we submitted an intronic variant while not using an NC reference sequence.
        // VV doesn't complain about this, as they accept the genome build as a separate argument.
        if ($HGVS->ReferenceSequence->molecule_type == 'transcript'
            && !empty($HGVS->Variant->DNAVariantBody->DNAPositions->intronic)) {
            $aData['warnings']['WINTRONICWITHOUTNC'] = 'Without using a genomic reference sequence, intronic bases can not be verified.' .
                (empty($aJSON['genome_context_intronic_sequence']) || empty($aJSON['submitted_variant'])? ''
                    : ' Please consider passing the variant as ' .
                    strstr($aJSON['genome_context_intronic_sequence'], ':', true) . strstr($aJSON['submitted_variant'], ':') . '.');
        }

        // Different input types find their validated output in different fields.
        $sDNAField = 'hgvs_transcript_variant';
        $bGenomic = false;
        if ($HGVS->ReferenceSequence->getIdentifiedAs() == 'refseq_genomic') {
            // E.g., NG_007400.1:g.8638G>T.
            $sDNAField = 'hgvs_refseqgene_variant';
            $bGenomic = true;
        } elseif ($HGVS->ReferenceSequence->getIdentifiedAs() == 'LRG_genomic') {
            // E.g., LRG_1:g.8638G>T.
            $sDNAField = 'hgvs_lrg_variant';
            $bGenomic = true;
        } elseif ($HGVS->ReferenceSequence->getIdentifiedAs() == 'LRG_transcript') {
            // E.g., LRG_1t1:c.589G>T.
            $sDNAField = 'hgvs_lrg_transcript_variant';
        }

        // Prepare the data array.
        $aData['data']['DNA'] = '';
        if ($bGenomic) {
            $aData['data']['genomic_mappings'] = array();
            $aData['data']['transcript_mappings'] = array();
        } else {
            $aData['data']['RNA'] = '';
            $aData['data']['protein'] = '';
            $aData['data']['NP'] = '';
            $aData['data']['genomic_mappings'] = array();
        }

        // If we have sent an NG or LRG:g, we end up with an array of possible NM mappings.
        // When we send a transcript-based variant, we end up with only one NM here.
        // To handle everything, make sure we loop through the data.
        foreach ($aJSON as $sDNA => $aTranscript) {
            // Skip transcripts/arrays without a DNA value. That happens when, e.g., an NG:g variant is submitted.
            // The returned mappings are not all actual mappings to the NG, and they don't contain a validated variant.
            if (empty($aTranscript[$sDNAField])) {
                continue;
            }

            // Copy the validated DNA description over.
            $aData['data']['DNA'] = $aTranscript[$sDNAField];

            // If description is given but different, then apparently there's been some kind of correction.
            if ($sVariant != $aData['data']['DNA']) {
                // Check why the variant returned by VV and the input variant differ.
                $this->detectDNAChangeType($aData, $sVariant, $HGVS);
            }

            // If we get an NM back but put in an NC(NM), restore things.
            if ($bRefSeqWasCleaned) {
                $aData['data']['DNA'] = $HGVS->ReferenceSequence->getCorrectedValue() . strstr($aData['data']['DNA'], ':');
            }

            if (strpos($sDNA, ':') !== false) {
                $sTranscript = strstr($sDNA, ':', true);
                $aMapping = array(
                    'DNA' => substr(strstr($sDNA, ':'), 1), // Mappings don't have the transcript included.
                    'RNA' => 'r.(?)',
                    'protein' => '',
                    'NP' => '',
                );
                if ($aTranscript['hgvs_predicted_protein_consequence']['tlr']) {
                    list($aMapping['NP'], $aMapping['protein']) = explode(':', $aTranscript['hgvs_predicted_protein_consequence']['tlr'], 2);
                }

                // Try to improve VV's predictions.
                $this->getRNAProteinPrediction($aMapping, $sTranscript);

                // If we sent a transcript, use this as the output. If we sent something genomic, add this as a mapping.
                if ($bGenomic) {
                    $aData['data']['transcript_mappings'][$sTranscript] = $aMapping;
                } else {
                    // We had already collected the DNA value with the reference sequence, so don't overwrite that.
                    $aData['data']['RNA'] = $aMapping['RNA'];
                    $aData['data']['protein'] = $aMapping['protein'];
                    $aData['data']['NP'] = $aMapping['NP'];
                }
            }

            // Any errors given?
            if ($aTranscript['validation_warnings']) {
                // Not a previously seen error; those are handled through the flag value.
                // This can be a whole list, so loop through it.
                foreach ($aTranscript['validation_warnings'] as $sWarning) {
                    $this->addFault($aData, $sWarning, $sVariant, $HGVS);
                }
            }

            // Genomic mappings, when present, are given per transcript.
            foreach (($aTranscript['primary_assembly_loci'] ?? []) as $sBuild => $aMapping) {
                // We support only the builds we have...
                if (!isset(HGVS_Genome::getBuilds()[$sBuild])) {
                    continue;
                }

                // This structure is different from the LOVD endpoint. Each genome build has only one mapping here.
                // However, there can be more than one mapping per build in theory, when transcripts map differently.
                $aData['data']['genomic_mappings'][$sBuild][] = $aMapping['hgvs_genomic_description'];
            }

            // PAR genes (e.g., SHOX) provide X mappings in primary_assembly_loci and Y mappings in alt_genomic_loci.
            foreach (($aTranscript['alt_genomic_loci'] ?? []) as $aMappings) {
                // This array has yet another data structure... sigh. There are three ways that VV provides mappings.
                foreach ($aMappings as $sBuild => $aMapping) {
                    // We support only the builds we have...
                    if (!isset(HGVS_Genome::getBuilds()[$sBuild])) {
                        continue;
                    }

                    // There can be more than one mapping per build in theory, when transcripts map differently.
                    $aData['data']['genomic_mappings'][$sBuild][] = $aMapping['hgvs_genomic_description'];
                }
            }
        }

        // Clean up duplicates from multiple transcripts.
        foreach ($aData['data']['genomic_mappings'] as $sBuild => $aMappings) {
            $aData['data']['genomic_mappings'][$sBuild] = array_unique($aMappings);
        }
        return $aData;
    }
}
